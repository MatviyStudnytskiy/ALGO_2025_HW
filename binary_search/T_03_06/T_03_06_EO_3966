import sys
import bisect  # модуль використаємо для оптимізуації пошуку

# Ефективне зчитування вхідних даних (швидше ніж кілька input())
input_data = sys.stdin.read().split()

# кількість видів метеликів у колекції
n = int(input_data[0])

# Зчитати відсортований список видів метеликів (ID або номери)
# Відсортований для коректної роботи бінарного пошуку
butterflies = list(map(int, input_data[1:n+1]))

# Кількість видів метеликів у колекції
m = int(input_data[n+1])

# Види, які ми хочемо шукати в колекції
queries = list(map(int, input_data[n+2:n+2+m]))

# Список для зберігання результатів для кожного запиту
result = []

# Обробка кожного із запитів по виду по черзі
for q in queries:
    # Використовуємо бінарний пошук, щоб знайти крайню ліву позицію, куди можна вставити 'q'
    # Зі збереженням відсортованого порядку списку 'butterflies'
    idx = bisect.bisect_left(butterflies, q)

    # bisect_left повертає індекс, на який потрапить 'q', якщо його вставити:
    # якщо 'q' вже є у списку, idx вказує на перше входження
    # якщо ні, то idx вказує на місце вставки, щоб список залишався відсортованим

    # Тепер перевіримо, чи елемент з індексом 'idx' дійсно дорівнює 'q'
    # Тобто підтвердимо 'q' присутній у списку
    if idx < n and butterflies[idx] == q:
        result.append("YES")  # За індексом 'idx' знайдено 'q'
    else:
        result.append("NO")   # 'q' відсутній у списку
# Ефективно виведемо усі результати одразу
sys.stdout.write("\n".join(result) + "\n")
